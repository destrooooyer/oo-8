# 需求分析文档
### 本次作业的需求：
* 通过文件输入80*80的地图
* 系统随机产生100辆车
* 车有4种状态，100ms移动距离1
  * 即将服务：走最短路到乘客位置，到达后停止运行1s后变为正在服务
  * 正在服务：走最短路到请求的目标位置，之后停止1s
  * 等待服务：随机移动，持续20s后变为停止运行1s
  * 停止运行：1s内不动
* 车具有信用度，抢单+1，完成请求+3
* 系统初始化后乘客可发出请求，3s内4*4的区域内的出租车都可抢单，3s后，系统按如下规则分配出租车完成请求
  * 处于等待状态且抢过单的出租车才有可能被选中
  * 优先挑选信用度高的出租车
  * 信用度相同挑选离乘客距离近的
* 设计者为测试者提供观察车辆状态的接口以及获得当前时刻的接口

### 为完成需求进行的设计：
* `map`类：实现地图相关的需求
  * `point`内部类：记录一个点与其上下左右四个点的连通性
  * `read_file`方法：从文件读取地图数据
  * `init`方法：初始化地图信息，由输入的数据获得地图上每个点与周围点的连通性
* `car`类：实现出租车相关的需求
  * `move`方法：根据出租车当前的状态，决定移动一次之后的位置（若为停止运行状态则不动）
  * `update_status`方法：更新出租车的当前状态
  * `find_shortest_path`方法：找地图上两个点之间的最短路径
  * `status_kinds`内部类：枚举所有出租车的可能状态
* `request`类：
  * 记录请求信息
  * 计时3s之后通知调度器分配请求
* `disp`类：调度器类，实现对请求，还有出租车的调度
  * `car_watcher`内部类：为测试者提供观察车辆状态的接口以及获得当前时刻的接口
  * `private car[] cars`：100辆出租车
  * `private LinkedList<request> requests`：请求队列
  * `add_request`方法：向请求队列中添加新的请求
  * `complete_req`方法：请求的3s窗口结束后，对出租车进行调度，按需求中的规则选择出租车完成请求
  * `run`方法：每隔100ms让所有车移动一次，更新一次车的状态，并将请求发送给范围内的出租车使其抢单
